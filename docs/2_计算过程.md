# 计算过程

**Tips: 所有的图示的计算过程不是非常严谨**

学会忽略细节，理解复杂事物的关键是，避免不必要的观察、计算和思考。

```lisp
; 求两个数的平方和

(define (sos x y)
    (+ (square x) (square y)))

(define (square x) (* x x))
```

我们来看下对 (sos 3 4) 的求和过程，过程并不完整，比如忽略了 乘法`*` 等运算符的计算过程。

```mermaid
graph TD;
A["(sos 3 4)"] --> B["(+ (square 3) (square 4))"];
B --> C["(+ (square 3) (* 4 4))"];
C --> D["(+ (square 3) 16)"];
D --> E["(+ (* 3 3) 16)"];
E --> F["(+ 9 16)"];
F --> 25
```

上面是**应用代换模型**的基本方法。
**Tips：** **代换模型**并不能准确描述计算机实际的运行方式。

## 写一个加法的运算过程：

```lisp
; 这个运算过程相当于，有两堆弹珠 X 和 Y
; 从 X 取一个弹珠，放进 Y 
; 当 X 取到 0 时，那么 Y 就是全部的弹珠

(define (+ x y )
  (if (= x 0)
    y
    (+ (-1+ x) (1+ y))))
```

根据上面的代码描述下 `(+ 3 4)` 的过程 (会省略一些步骤)。

```mermaid
graph TD
A --> E
E --> I
I --> K

subgraph four
K["(+ 0 7)"] --> L{"(= 0 0)"}
L --> |true| M["7"]
end

subgraph three
I["(+ 1 6)"] --> |"..."| J["(+ 0 7)"]
J --> I
end

subgraph two
E["(+ 2 5)"] --> F{"(= 2 0)"}
F --> |false| G["+ (-1+ 2) (1+ 5))"]
G --> H["(+ 1 6)"]
H --> E
end

subgraph one
A["(+ 3 4)"] --> B{"(= 3 0)"}
B --> |false| C["(+ (-1+ 3) (1+ 4))"]
C --> D["(+ 2 5)"]
D --> A
end

```

将上面的过程进行简化

```mermaid
graph TD
AA["(+ 3 4)"] --> BB["(+ 2 5)"]
BB --> CC["(+ 1 6)"]
CC --> DD["(+ 0 7)"]
DD --> EE[7]

```

## 加法运算过程的另一种写法：

```lisp
(define (+ x y)
  (if (= x 0)
    y
    (1+ (+ (-1+ x) y))))
```

根据上面的代码描述下 `(+ 3 4)` 的过程 (会省略一些步骤)。

```mermaid
graph TD

D --> E
K --> L
S --> T


U --> AA
V --> AA
W --> AA
subgraph four
T["(1+ (1+ (1+ (+ 0 4))))"] --> U["(1+ _)"]
T --> V["(1+ _)"]
T --> W["(1+ _)"]
T --> X["(+ 0 4)"]
X --> Y{"(= 0 0)"}
Y --> |ture| Z[4]
Z --> AA["(1+ (1+ (1+ 4)))"]
AA --> BB["(1+ (1+ 5))"]
BB --> CC["(1+ 6)"]
CC --> DD[7]
end

M --> S
N --> S
subgraph three
L["(1+ (1+ (+ 1 4)))"] --> M["(1+ _)"]
L --> N["(1+ _)"]
L --> O["(+ 1 4)"]
O --> P{"(= 1 0)"}
P --> |false| Q["(1+ (+ (-1+ 1) 4))"]
Q --> R["(1+ (+ 0 4))"]
R --> S["(1+ (1+ (1+ (+ 0 4))))"]
end

F --> K
subgraph two
E["(1+ (+ 2 4)"] --> F["(1 _)"]
E --> G["(+ 2 4)"]
G --> H{"(= 2 0)"}
H --> |false| I["(1+ (+ (-1+ 2) 4))"]
I --> J["(1+ (+ 1 4))"]
J --> K["(1+ (1+ (+ 1 4)))"]
end

subgraph one
A["(+ 3 4)"] --> B{"(= 3 0)"}
B --> |false| C["(1+ (+ (-1+ 3) 4))"]
C --> D["(1+ (+ 2 4))"]
end
```

将上面的过程进行简化

```mermaid
graph TD;
A["(+ 3 4)"] --> B["(1+ (+ 2 4))"]
B --> C["(1+ (1+ (1+ 4)))"]
C --> D["(1+ (1+ (1+ (+ 0 4))))"]
D --> E["(1+ (1+ (1+ 4))"]
E --> F["(1+ (1+ 5))"]
F --> G["(1+ 6)"]
G --> H[7]
```

## 将两种加法运算过程进行对比

```mermaid
graph TD

subgraph The second
A["(+ 3 4)"] --> B["(1+ (+ 2 4))"]
B --> C["(1+ (1+ (1+ 4)))"]
C --> D["(1+ (1+ (1+ (+ 0 4))))"]
D --> E["(1+ (1+ (1+ 4))"]
E --> F["(1+ (1+ 5))"]
F --> G["(1+ 6)"]
G --> H[7]
end

subgraph The first
AA["(+ 3 4)"] --> BB["(+ 2 5)"]
BB --> CC["(+ 1 6)"]
CC --> DD["(+ 0 7)"]
DD --> EE[7]
end


```

上面也就是**迭代**和**递归**的区分。

## 斐波那契数列 (继续探讨计算过程)

一个简单的斐波那契数，例子，如下图。

```mermaid
graph LR

subgraph index
AA[0] --> BB[1] 
BB --> CC[2]
CC --> DD[3]
DD --> EE[4]
EE --> FF[5]
FF --> GG[6]
GG --> HH[7]
HH --> II[8]
II --> JJ[9]
JJ --> KK[10]
end

subgraph num
A[0] --> B[1] 
B --> C[1]
C --> D[2]
D --> E[3]
E --> F[5]
F --> G[8]
G --> H[13]
H --> I[21]
I --> J[34]
J --> K[55]
end

```

用代码写出来：

```lisp
(define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1))
           (fib (- n 2)))))
```

写出 (fib 4) 的简化的计算过程：

```mermaid
graph TD

A["fib 4"] --> B["fib 3"]
A --> C["fib 2"]

B --> D["fib 2"]
B --> E["fib 1"]

D --> F["fib 1"]
D --> G["fib 0"]

C --> H["fib 1"]
C --> I["fib 0"]

F --> J[1]
G --> K[0]

E --> L[1]

H --> M[1]
I --> N[0]

```

可以看到上面的求斐波那契数列的算法是很糟糕的，例如上图 `fib 2` 被计算了两次。

假设我要求 `fib 5` 的话，那么 `fib 3` 会被重复计算，时间复杂度呈指数增长。